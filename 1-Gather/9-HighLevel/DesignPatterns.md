# 前端设计模式

> 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。

任何事情都有套路，设计模式，就是写代码中常见的套路，有些写法我们日常都一直在使用。

### 订阅/发布模式（观察者）

pub/sub这个应该大家用到最广的设计模式了，

在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者因此也成为观察者，而被观察的对象成为发布者。当发生了一个重要事件的时候。

发布者会通知所有订阅者并且可能经常以事件对象的形式传递消息。



- **自己实现**

  ```js
  jjj
  ```

- **应用场景**

  vue中的$emit, $on源码 大概也是这个样子

  https://github.com/vuejs/vue/blob/dev/src/core/instance/events.js#L54

### 单例模式

> 单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

- **适用场景**

  一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次，实现起来也很简单，一个变量缓存即可

- **自己实现**

  ```js
  www
  ```

  

- **应用场景**

  我们在element中的弹窗代码中，可以看到单例模式的实例案例，保证全局唯一性

  我们再element中的弹窗代码中，可以看到单例模式的实际案例 保证全局唯一性

  https://github.com/ElemeFE/element/blob/dev/packages/message-box/src/main.js#L79

### 策略模式

> 策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。
>
> 策略模式的目的就是将算法的使用、算法的实现分离开来。
>
> 一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某一个策略类。要做到这一点，说明Context中要维持对某个策略对象的引用

- **应用场景**

  表单校验

  ```js
  www
  ```

### 代理模式

> 代理模式的定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
>
> 常用的虚拟代理形式：某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建（例：使用虚拟代理实现图片懒加载）
>
> 图片懒加载的方式：先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面

```js
222
```



假设我们在做一个文件同步的功能，当我们选中一个checkbox的时候，它对应的文件就会被同步到另外一台备用服务器上面服务器上面。当一次选中过多时，会产生频繁的网络请求。将带来很大的开销。可以通过一个代理函数proxySynchronousFile开收集一段时间之内的请求，最后一次性发送给服务器



### 中介者模式

> 中介者模式：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系

- **应用场景**

  例如：购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会出发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。

  redux，vuex都属于中介者模式的实际应用，我们把共享的数据，抽离成一个单独的store，每个都通过store这个中介来操作对象

  目的就是减少耦合

### 装饰器模式

> 装饰器模式：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。常见应用，react的高阶组件，或者react-redux中的@connect或者自己定义一些高阶组件



装饰器模式和代理模式的结构看起来非常像，这两种模式都描述了怎样为对象提供一定程度上的间接引用，它们的实现部分都保留了对另外一个对象的引用，并且向那个对象发送请求。代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对象动态加入行为。



### 外观模式

> 外观模式即让多个方法一起呗调用
>
> 涉及到兼容性，参数支持多格式，有很多这种代码，对外暴露统一的api，比如上面的$on支持数组，​
>
> $off参数支持多个情况，对面只用一个函数，内部判断实现

- **自己实现**

  

1. 学习设计模式的必要性
2. 面向对象
3. 工程模式
4. 单例模式
5. 装饰器模式
6. 代理模式
7. 观察者模式
8. 设计模式实战













