# 全局作用域中，用const 和let声明的变量不在 window 上,那到底在哪里？如何去获取

在ES5中，全局变量直接挂载到全局对象的属性上，所以能在window上看到var声明的变量

在ES6中，全局对象的属性和全局变量脱钩，但是为了保持兼容性，旧的不变，所以var、function声明的全局变量依然可以再window对象上看到，而let、const声明的全局变量在window对象上看不到

```js
let a=1;
let b=2;
let Object={
  a:3,
  d:function(){
    console.log(this.b)
    console.log(a)
    console.log(this.a)
  }
}

let ed=Object.d;
ed()//2,1,undefined
```

此时this指向window，通过window.a访问为undefined，由于const和let声明的变量不在window上，所有通过直接访问即可



**扩展：let、const以及var的区别是什么？**

- let和const定义的变量不会出现变量提升，而var定义的变量会提升
- let和const是JS中的块级作用域
- let和const定义的变量在定义语句之前，如果使用会抛出错误（形成暂时性死区），而var不会
- const声明一个只读的常量。一旦声明，常量的值就不能改变（如果声明一个对象，那么不能改变的是对象的引用地址）

let/const也存在变量的声明提升，只是没有初始化分配内存。一个变量有三个操作，声明（提到作用域顶部），初始化（赋默认值），赋值（继续赋值）

let是一开始变量声明提升，然后没有初始化分配内存，代码执行到那行初始化，之后对变量继续操作是赋值。因为没有初始化分配内存，所以会报错，这是暂时性死区