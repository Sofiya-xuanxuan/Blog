### 1.写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

> key是给每一个vnode的唯一id,可以`依靠key`,更`准确`, 更`快`的拿到oldVnode中对应的vnode节点。

1. **更准确**

因为带key就不是`就地复用`了，在sameNode函数 `a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。

2. **更快**

利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。)

<font color='red'>**总结：key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。就我的使用来说(Vue)key的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用。另外，某些情况下，不带key可能性能更好**</font>



### 2.['1', '2', '3'].map(parseInt) what & why ?

> 真正的答案是[1, NaN, NaN]

- 首先让我们回顾一下，map函数的第一个参数callback：

```basic
var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])
```

这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。



- 而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。

  ```bash
  parseInt(string, radix)
  ```

  接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

  | 参数   | 描述                                                         |
  | :----- | :----------------------------------------------------------- |
  | string | 必需。要被解析的字符串。                                     |
  | radix  | 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 |

- 了解这两个函数后，我们可以模拟一下运行情况

1. parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1
2. parseInt('2', 1) //基数为1，该参数小于2，所以无法解析，返回NaN
3. parseInt('3', 2) //基数为2（2进制）'3'在2进制中是一个非法的值，2进制中只能存在0和1，所以无法解析，返回NaN

- map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]

<font color='red'>**总结：parseInt 将字符串转化成数字，要设置第二个参数为 10。如果不设置第二个参数，以 `0` 打头的数字会认为是八进制的数，如**</font>

```bash
parseInt('09') # 我的Chrome（版本 60） 返回 9。有些浏览器会认为 09 是八进制的数，但 8进制数中不包含数字9，所以最终的结果是0。
parseInt('09', 10) # 这样写就不会出问题。
```



### 3.什么是防抖和节流？有什么区别？如何实现？

1）**防抖**

> 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次触发，则重新计算时间

- 思路

每次触发事件时都取消之前的延时调用方法

```bash
function debounce(fn) {
      let timeout = null; // 创建一个标记用来存放定时器的返回值
      return function () {
        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
          fn.apply(this, arguments);
        }, 500);
      };
}
    
function sayHi() {
    console.log('防抖成功');
}

var inp = document.getElementById('inp');
inp.addEventListener('input', debounce(sayHi)); // 防抖
```

2）**节流**

> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

- 思路

每次触发事件时都判断当前是否有等待执行的延时函数

```bash
function throttle(fn) {
      let canRun = true; // 通过闭包保存一个标记
      return function () {
        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
        canRun = false; // 立即设置为false
        setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
          fn.apply(this, arguments);
          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
          canRun = true;
        }, 500);
      };
}

function sayHi(e) {
  console.log(e.target.innerWidth, e.target.innerHeight);
}

window.addEventListener('resize', throttle(sayHi));
```



### 4.介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

- **set**

ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

Set本身是一个构造函数，用来生成Set数据结构

### 5.介绍下深度优先遍历和广度优先遍历，如何实现？

![深度和广度](/Users/qiaoxu/Desktop/myBlog/pic/deepwidth.png)

我们将用深度优先遍历和广度优先遍历对这个dom树进行查找

- **深度优先遍历**

  深度优先遍历DFS与树的先序遍历比较类似

  假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点然后依次从它的各个未被访问的领接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止

  ```bash
  /*深度优先遍历三种方式*/
  let deepTraversal1 = (node, nodeList = []) => {
    if (node !== null) {
      nodeList.push(node)
      let children = node.children
      for (let i = 0; i < children.length; i++) {
        deepTraversal1(children[i], nodeList)
      }
    }
    return nodeList
  }
  let deepTraversal2 = (node) => {
      let nodes = []
      if (node !== null) {
        nodes.push(node)
        let children = node.children
        for (let i = 0; i < children.length; i++) {
          nodes = nodes.concat(deepTraversal2(children[i]))
        }
      }
      return nodes
    }
  // 非递归
  let deepTraversal3 = (node) => {
    let stack = []
    let nodes = []
    if (node) {
      // 推入当前处理的node
      stack.push(node)
      while (stack.length) {
        let item = stack.pop()
        let children = item.children
        nodes.push(item)
        // node = [] stack = [parent]
        // node = [parent] stack = [child3,child2,child1]
        // node = [parent, child1] stack = [child3,child2,child1-2,child1-1]
        // node = [parent, child1-1] stack = [child3,child2,child1-2]
        for (let i = children.length - 1; i >= 0; i--) {
          stack.push(children[i])
        }
      }
    }
    return nodes
  }
  
  ```

  输出结果：

  ![深度优先](/Users/qiaoxu/Desktop/myBlog/pic/deepresult.png)

- **广度优先遍历**

  广度优先遍历BFS

  从图中某个顶点v出发，在访问了v之后依次访问v的各个未曾访问过的领接点，然后分别从这些领接点出发依次访问它们的领接点，并使得“先被访问的顶点的领接点先于后被访问的顶点的领接点被访问，直至图中所有已被访问的顶点的领接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未被访问过得顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

  ```bash
  let widthTraversal2 = (node) => {
    let nodes = []
    let stack = []
    if (node) {
      stack.push(node)
      while (stack.length) {
        let item = stack.shift()
        let children = item.children
        nodes.push(item)
          // 队列，先进先出
          // nodes = [] stack = [parent]
          // nodes = [parent] stack = [child1,child2,child3]
          // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]
          // nodes = [parent,child1,child2]
        for (let i = 0; i < children.length; i++) {
          stack.push(children[i])
        }
      }
    }
    return nodes
  }
  ```

  输出结果：

  ![广度优先](/Users/qiaoxu/Desktop/myBlog/pic/widthresult.png)

### 6.请分别用深度优先思想和广度优先思想实现一个拷贝函数

### 7.JS异步解决方案的发展历程以及优缺点

阮一峰：[http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html](http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html)

**1）回调函数（callback）**

```bash
setTimeout(()=>{
	//callback函数体
},1000)
```

<font color='red'>缺点：回调地狱，不能用try catch捕获错误，不能return</font>

回调地狱的根本问题在于：

- 缺乏顺序性：回调地狱导致调试困难，和大脑的思维方式不符
- 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）
- 嵌套函数过多的话，很难处理错误

```bash
ajax('XXX1', () => {
    // callback 函数体
    ajax('XXX2', () => {
        // callback 函数体
        ajax('XXX3', () => {
            // callback 函数体
        })
    })
})
```

<font color='red'>优点：解决了同步的问题（只有一个任何耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</font>

**2）Promise**

Promise就是为了解决callback的问题而产生的。

promise实现了链式调用，也就是说每次then后返回的都是一个全新的Promise，如果我们在then中return，return的结果会被Promise.resolve()包装

<font color='red'>优点：解决了回调地狱问题</font>

```bash
ajax('XXX1')
  .then(res => {
      // 操作逻辑
      return ajax('XXX2')
  }).then(res => {
      // 操作逻辑
      return ajax('XXX3')
  }).then(res => {
      // 操作逻辑
  })
```

<font color='red'>缺点：无法取消promise，错误需要通过回调函数来捕获</font>

**3）Generator**

特点：可以控制函数的执行，可以配合co函数库使用

```bash
function *fetch() {
    yield ajax('XXX1', () => {})
    yield ajax('XXX2', () => {})
    yield ajax('XXX3', () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

**4）Async/await**

Async、await是异步的终极解决防范

<font color='red'>优点：代码清晰，不用像Promise写一大堆then链，处理了回调地狱问题</font>

<font color='red'>缺点：await将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用await会导致性能上降低</font>

```bash
async function test() {
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch('XXX1')
  await fetch('XXX2')
  await fetch('XXX3')
}
```

下面来看一个await的例子：

```bash
let a = 0
let b = async () => {
  a = a + await 10
  console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1
```

对于以上代码你可能会有疑惑，让我来解释下原因

- 首先函数 `b` 先执行，在执行到 `await 10` 之前变量 `a` 还是 0，因为 `await` 内部实现了 `generator`，**generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来**
- 因为 `await` 是异步操作，后来的表达式不返回 `Promise` 的话，就会包装成 `Promise.reslove(返回值)`，然后会去执行函数外的同步代码
- 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 `a = 0 + 10`

上述解释中提到了 `await` 内部实现了 `generator`，其实 `await` 就是 `generator` 加上 `Promise`的语法糖，且内部实现了自动执行 `generator`。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。

### 8.ES5/ES6的继承除了写法以外还有什么区别？

- **ES6-class的一些特性：**

1）class声明会提升，但不会初始化赋值。`Foo`进入暂时性死区，类似于`let` 、`const`声明变量。

```bash
const bar=new Bar()#it's ok
function Bar(){
	this.bar=42
}

const foo=new Foo()#ReferenceError: Foo is not defined
class Foo{
	constructor(){
		this.foo=42
	}
}
```

2）class声明内部会启用严格模式

```bash
//引用一个未声明的变量
function Bar(){
	baz=42 # it's ok
}
const bar=new Bar()

class Foo{
	constructor(){
		fol=42 # ReferenceError: fol is not defined
	}
}

const foo=new Foo()
```

3）class的所有方法（包括静态方法和实例方法）都是不可枚举的。

```bash
//引用一个未声明的变量
function Bar(){
	this.bar=42
}
Bar.answer=function(){
	return 42
}
Bar.prototype.print=function() {
	console.log(this.bar)
}
const barKeys=Object.keys(Bar)#['answer']
const barProtoKeys=Object.keys(Bar.prototype)#['print']

class Foo{
	constructor(){
		this.foo=42
	}
	static answer(){
		return 42
	}
	print(){
		console.log(this.foo)
	}
}
const fooKeys=Object.keys(Foo)#[]
const fooProtoKeys=Object.keys(Foo.prototype)#[]
```

4）class的所有方法（包括静态方法和实例方法）都没有原型对象prototype，所以也没有[construct]，不能使用`new`来调用

```bash
function Bar(){
	this.bar=42
}
Bar.prototype.print=function(){
	console.log(this.bar)
}
const bar=new Bar()
const barPrint=new bar.print()#it's ok

class Foo{
	construtor(){
		this.foo=42
	}
	print(){
		console.log(this.foo)
	}
}
const foo=new Foo()
const fooPrint=new foo.print()#TypeError: foo.print is not a constructor
```

5）必须使用`new`来调用class

```bash
function Bar(){
	this.bar=42
}
const bar=Bar()#it's ok

class Foo{
	construtor(){
		this.foo=42
	}
}
const foo=Foo()#TypeError: Class constructor Foo cannot be invoked without 'new'
```

6）class内部无法重写类名

```bash
function Bar(){
	Bar='Baz' #it's ok
	this.bar=42
}
const bar=new Bar()
#Bar: 'Baz'
#bar: Bar {bar: 42}

class Foo{
	construtor(){
		this.foo=42
		Foo='Fol'#TypeError: Assignment to constant variable
	}
}
const foo=new Foo()
Foo='Fol'#it's ok
```

7）子类`this`生成顺序不同

ES5的继承优先生成了子类实例，再调用父类的构造函数修饰子类实例，ES6的继承优先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得ES6可以继承内置对象。

```bash
function MyES5Array(){
	Array.call(this,argument)
}
#it's useless
const arrayES5=new MyES5Array(3)#arrayES5: MyES5Array {}

#it's ok
class MyES6Array extends Array{}
const arrayES6=new MyES6Array(3)#arrayES6: MyES6Array(3) []
```

<font color='red'>ES5 的继承，实质是先创造子类的实例对象`this`，然后再将父类的方法添加到`this`上面（`Parent.apply(this)`）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后再用子类的构造函数修改`this`。</font>

- **ES5/ES6继承的区别**

JavaScript相比于其他面向类的语言，在实现继承时并没有真正对构造类进行复制，当我们使用`var children=new Parent()`继承父类时，我们理所当然的理解为children**为parent所构造**。实际上这是一种错误的理解。严格来说，JS才是真正的面向对象语言，而不是面向类语言。它所实现的继承，都是通过每个对象创建之初就存在的`prototype`属性进行关联、委托，从而建立联系，间接的实现继承，实际上不会复制父类

> ES5常见的两种继承：原型链继承、构造函数继承

1）原型链继承

```bash
#定义父类
function Parent(name){
	this.name=name
}
Parent.prototype.getName=function() {
	return this.name
}
#定义子类
function Children(){
	this.age=24
}
#通过Children的prototype属性和Parent进行关联继承
Children.prototype=new Parent('陈先生')#Children.prototype.construtor===Parent.prototype.construtor===Parent

var test=new Children()#test.construtor===Children.prototype.construtor===Parent
test.age//24
test.getName()//陈先生
```

我们可以发现，整个继承过程，都是通过原型链之间的指向进行委托关联，直到最后形成了`由构造函数所构造`的结局

2）构造函数继承

```bash
#定义父类
function Parent(value){
	this.language=['javascript', 'react', 'node.js']
	this.value=value
}
#定义子类
function Children(){
	Parent.apply(this,arguments)
}
const test=new Children(6666)
test.language//['javascript', 'react', 'node.js']
test.value//6666
```

构造函数关键在于，通过在子类的内部调用父类，即通过使用`apply()`或`call()` 方法可以再将来新创建的对象上获取父类的成员和方法

> ES6的继承

```bash
# 定义父类
class Father {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    show() {
        console.log(`我叫:${this.name}， 今年${this.age}岁`);
    }
};

// 通过extends关键字实现继承
class Son extends Father {};

let son = new Son('陈先生', 3000);

son.show(); // 我叫陈先生 今年3000岁
```

ES6中新增了class关键字来定义类，通过保留的关键字`extends`实现了继承。实际上这些关键字只是一些语法糖，底层实现还是通过原型链之间的委托关联关系实现继承

> 总结

区别于ES5的继承，ES6的继承实现在于使用`super`关键字调用父类，反观ES5是通过call或者apply回调方法调用父类

















### 输入URL发生了什么

1.DNS解析

2.TCP连接

Http1.0  1.1 2.0区别

3.服务端——>客户端html

4.客户端解析html

​	浏览器多线程

 - GUI线程——解析html、css

   dom-tree+css-tree——>render-tree

   Css:布局layout——paint

 - Js线程

   单线程

   主线程执行完毕后，事件循环机制（eventloop）

   消息队列：macroTask——setTimeOut、setInterval、setImmediate、I/O

   ​					microTask——promise、process、nextTick

 - 定时器线程

 - ajax线程

	- 事件处理线程

### 缓存



### 响应式原理



### 递归



### 数组



[promise,promise]=









